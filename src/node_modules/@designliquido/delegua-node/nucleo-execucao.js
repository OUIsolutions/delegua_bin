"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NucleoExecucao = void 0;
const caminho = __importStar(require("path"));
const readline = __importStar(require("readline"));
const chalk_1 = __importDefault(require("chalk"));
const json_colorizer_1 = __importDefault(require("json-colorizer"));
const avaliador_sintatico_1 = require("@designliquido/delegua/avaliador-sintatico");
const dialetos_1 = require("@designliquido/delegua/avaliador-sintatico/dialetos");
const dialetos_2 = require("@designliquido/delegua/interpretador/dialetos");
const lexador_1 = require("@designliquido/delegua/lexador");
const dialetos_3 = require("@designliquido/delegua/lexador/dialetos");
// import { LexadorPortugolStudio } from "@designliquido/portugol-studio/lexador";
// import { AvaliadorSintaticoPortugolStudio } from '@designliquido/portugol-studio/avaliador-sintatico';
// import { InterpretadorPortugolStudio, InterpretadorPortugolStudioComDepuracao } from '@designliquido/portugol-studio/interpretador';
const importador_1 = require("./importador");
const depuracao_1 = require("./depuracao");
const formatadores_1 = require("./formatadores");
const lexador_json_1 = require("./lexador/lexador-json");
const lexador_2 = require("@designliquido/visualg/lexador");
const avaliador_sintatico_2 = require("@designliquido/visualg/avaliador-sintatico");
const interpretador_1 = require("@designliquido/visualg/interpretador");
const potigol_1 = require("@designliquido/potigol");
const interpretador_2 = require("./interpretador");
const interpretador_mapler_com_depuracao_importacao_1 = require("./interpretador/dialetos/interpretador-mapler-com-depuracao-importacao");
const interpretador_visualg_com_depuracao_importacao_1 = require("./interpretador/dialetos/interpretador-visualg-com-depuracao-importacao");
const interpretador_com_depuracao_importacao_1 = require("./interpretador/interpretador-com-depuracao-importacao");
const nucleo_comum_1 = require("./nucleo-comum");
class NucleoExecucao extends nucleo_comum_1.NucleoComum {
    constructor(versao, funcaoDeRetorno = null, funcaoDeRetornoMesmaLinha = null) {
        super();
        this.dialetos = {
            birl: "BIRL",
            delegua: "padrão",
            delégua: "padrão",
            egua: "Égua",
            égua: "Égua",
            mapler: "Mapler",
            pitugues: "Pituguês",
            pituguês: "Pituguês",
            potigol: "Potigol",
            "portugol-studio": "Portugol Studio",
            visualg: "VisuAlg",
        };
        this.versao = versao;
        this.arquivosAbertos = {};
        this.conteudoArquivosAbertos = {};
        this.funcaoDeRetorno = funcaoDeRetorno || console.log;
        // `process.stdout.write.bind(process.stdout)` é necessário por causa de
        // https://stackoverflow.com/questions/28874665/node-js-cannot-read-property-defaultencoding-of-undefined
        this.funcaoDeRetornoMesmaLinha =
            funcaoDeRetornoMesmaLinha || process.stdout.write.bind(process.stdout);
    }
    configurarDialeto(dialeto = "delegua", performance = false, depurador = false) {
        this.dialeto = dialeto;
        this.modoDepuracao = depurador;
        switch (dialeto) {
            case "birl":
                this.lexador = new dialetos_3.LexadorBirl();
                this.avaliadorSintatico = new dialetos_1.AvaliadorSintaticoBirl();
                this.importador = new importador_1.Importador(this.lexador, this.avaliadorSintatico, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = new dialetos_2.InterpretadorBirl(process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha);
                break;
            case "egua":
                if (depurador) {
                    throw new Error("Dialeto " + dialeto + " não suporta depuração.");
                }
                this.lexador = new dialetos_3.LexadorEguaClassico();
                this.avaliadorSintatico = new dialetos_1.AvaliadorSintaticoEguaClassico();
                this.importador = new importador_1.Importador(this.lexador, this.avaliadorSintatico, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = new dialetos_2.InterpretadorEguaClassico(process.cwd());
                break;
            case "mapler":
                this.lexador = new dialetos_3.LexadorMapler();
                this.avaliadorSintatico = new dialetos_1.AvaliadorSintaticoMapler();
                this.importador = new importador_1.Importador(this.lexador, this.avaliadorSintatico, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new interpretador_mapler_com_depuracao_importacao_1.InterpretadorMaplerComDepuracaoImportacao(this.importador, process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha)
                    : new dialetos_2.InterpretadorMapler(process.cwd(), false, this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha);
                break;
            case "pitugues":
            case "pituguês":
                this.lexador = new dialetos_3.LexadorPitugues();
                this.avaliadorSintatico = new dialetos_1.AvaliadorSintaticoPitugues();
                this.importador = new importador_1.Importador(this.lexador, this.avaliadorSintatico, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new interpretador_com_depuracao_importacao_1.InterpretadorComDepuracaoImportacao(this.importador, process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha)
                    : new interpretador_2.Interpretador(this.importador, process.cwd(), performance, this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha);
                break;
            case "portugol-ipt":
                this.lexador = new dialetos_3.LexadorPortugolIpt();
                this.avaliadorSintatico = new dialetos_1.AvaliadorSintaticoPortugolIpt();
                this.importador = new importador_1.Importador(this.lexador, this.avaliadorSintatico, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new dialetos_2.InterpretadorPortugolIpt(process.cwd(), this.funcaoDeRetornoMesmaLinha, this.funcaoDeRetornoMesmaLinha)
                    : new dialetos_2.InterpretadorPortugolIpt(process.cwd(), this.funcaoDeRetornoMesmaLinha, this.funcaoDeRetornoMesmaLinha);
                break;
            case "portugol-studio":
                this.lexador = new dialetos_3.LexadorPortugolStudio();
                this.avaliadorSintatico = new dialetos_1.AvaliadorSintaticoPortugolStudio();
                this.importador = new importador_1.Importador(this.lexador, this.avaliadorSintatico, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new dialetos_2.InterpretadorPortugolStudioComDepuracao(process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha)
                    : new dialetos_2.InterpretadorPortugolStudio(process.cwd(), performance, this.funcaoDeRetorno);
                break;
            case "potigol":
                this.lexador = new potigol_1.LexadorPotigol();
                this.avaliadorSintatico = new potigol_1.AvaliadorSintaticoPotigol();
                this.importador = new importador_1.Importador(this.lexador, this.avaliadorSintatico, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new potigol_1.InterpretadorPotigolComDepuracao(process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetorno)
                    : new potigol_1.InterpretadorPotigol(process.cwd(), performance, this.funcaoDeRetorno);
                break;
            case "visualg":
                this.lexador = new lexador_2.LexadorVisuAlg();
                this.avaliadorSintatico = new avaliador_sintatico_2.AvaliadorSintaticoVisuAlg();
                this.importador = new importador_1.Importador(this.lexador, this.avaliadorSintatico, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new interpretador_visualg_com_depuracao_importacao_1.InterpretadorVisuAlgComDepuracaoImportacao(this.importador, process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha)
                    : new interpretador_1.InterpretadorVisuAlg(process.cwd(), false, this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha);
                break;
            default:
                this.lexador = new lexador_1.Lexador(performance);
                this.avaliadorSintatico = new avaliador_sintatico_1.AvaliadorSintatico(performance);
                this.importador = new importador_1.Importador(this.lexador, this.avaliadorSintatico, this.arquivosAbertos, this.conteudoArquivosAbertos, depurador);
                this.interpretador = depurador
                    ? new interpretador_com_depuracao_importacao_1.InterpretadorComDepuracaoImportacao(this.importador, process.cwd(), this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha)
                    : new interpretador_2.Interpretador(this.importador, process.cwd(), performance, this.funcaoDeRetorno, this.funcaoDeRetornoMesmaLinha);
                break;
        }
        if (depurador) {
            this.iniciarDepuracao();
        }
    }
    async executarCodigoComoArgumento(codigo) {
        const retornoLexador = this.lexador.mapear([codigo], -1);
        const retornoAvaliadorSintatico = this.avaliadorSintatico.analisar(retornoLexador, -1);
        const { erros } = await this.executar({
            conteudoArquivo: [codigo],
            nomeArquivo: "",
            hashArquivo: -1,
            retornoLexador: retornoLexador,
            retornoAvaliadorSintatico: retornoAvaliadorSintatico,
        });
        if (erros.length > 0)
            process.exit(70); // Código com exceções não tratadas
    }
    /**
     * Execução por arquivo.
     * @param caminhoRelativoArquivo O caminho no sistema operacional do arquivo a ser aberto.
     */
    async carregarEExecutarArquivo(caminhoRelativoArquivo) {
        const caminhoAbsolutoPrimeiroArquivo = caminho.resolve(caminhoRelativoArquivo);
        const novoDiretorioBase = caminho.dirname(caminhoAbsolutoPrimeiroArquivo);
        this.importador.diretorioBase = novoDiretorioBase;
        this.interpretador.diretorioBase = novoDiretorioBase;
        const retornoImportador = this.importador.importar(caminhoRelativoArquivo, true);
        if (this.afericaoErros(retornoImportador)) {
            process.exit(65); // Código para erro de avaliação antes da execução
        }
        let errosExecucao = {
            lexador: [],
            avaliadorSintatico: [],
            interpretador: [],
        };
        // Se a interface de entrada e saída ainda não está definida, definimos agora.
        // A interface pode ser definida por um teste unitário antes da execução
        // aqui, por exemplo.
        let interfaceLeitura;
        if (!this.interpretador.interfaceEntradaSaida) {
            interfaceLeitura = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
                prompt: "\n> ",
            });
            this.interpretador.interfaceEntradaSaida = interfaceLeitura;
        }
        if (this.modoDepuracao) {
            try {
                this.interpretador.prepararParaDepuracao(retornoImportador.retornoAvaliadorSintatico.declaracoes);
            }
            catch (erro) {
                console.error(chalk_1.default.red(`[Erro de execução]`) +
                    ` Dialeto ${this.dialeto} não suporta depuração.`);
            }
        }
        else {
            const { erros } = await this.executar(retornoImportador);
            errosExecucao = erros;
        }
        if (interfaceLeitura && (interfaceLeitura instanceof readline.Interface || interfaceLeitura.hasOwnProperty("close"))) {
            interfaceLeitura.close();
        }
        if (errosExecucao.length > 0)
            process.exitCode = 70; // Código com exceções não tratadas
        return;
    }
    /**
     * LAIR (Leia-Avalie-Imprima-Repita) é o modo em que Delégua executa em modo console,
     * ou seja, esperando como entrada linhas de código fornecidas pelo usuário.
     */
    async iniciarLairDelegua() {
        const lexadorJson = new lexador_json_1.LexadorJson();
        const formatadorJson = new formatadores_1.FormatadorJson();
        this.funcaoDeRetorno(`Usando dialeto: ${this.dialetos[this.dialeto]}`);
        this.funcaoDeRetorno(`Console da Linguagem Delégua v${this.versao}`);
        this.funcaoDeRetorno("Pressione Ctrl + C para sair");
        const interfaceLeitura = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: "\ndelegua> ",
        });
        const isto = this;
        this.interpretador.interfaceEntradaSaida = interfaceLeitura;
        interfaceLeitura.prompt();
        interfaceLeitura.on("line", async (linha) => {
            const { resultado } = await isto.executarUmaLinha(linha);
            if (resultado && resultado.length) {
                const resultadoLexacao = lexadorJson.getTokens(resultado[0]);
                const resultadoFormatacao = formatadorJson.formatar(resultadoLexacao);
                isto.funcaoDeRetorno((0, json_colorizer_1.default)(resultadoFormatacao));
            }
            interfaceLeitura.prompt();
        });
    }
    /**
     * A execução do código de fato.
     * @param retornoImportador Dados retornados do Importador, como o retorno do Lexador, do Avaliador
     *                          Sintático e respectivos erros.
     * @param manterAmbiente Indicação se ambiente deve ser mantido ou não. Normalmente verdadeiro
     *                       para LAIR, falso para execução por arquivo.
     * @returns Um objeto com o resultado da execução.
     */
    async executar(retornoImportador, manterAmbiente = false) {
        var _a, _b;
        const retornoInterpretador = await this.interpretador.interpretar(retornoImportador.retornoAvaliadorSintatico.declaracoes, manterAmbiente);
        if (retornoInterpretador.erros.length > 0) {
            for (const erroInterpretador of retornoInterpretador.erros) {
                if (erroInterpretador.hasOwnProperty("simbolo")) {
                    this.erroEmTempoDeExecucao(erroInterpretador);
                }
                else {
                    if (erroInterpretador.hasOwnProperty("erroInterno")) {
                        const erroEmJavaScript = erroInterpretador;
                        console.error(chalk_1.default.red(`[Linha: ${erroEmJavaScript.linha}] Erro em JavaScript: `) + `${(_a = erroEmJavaScript.erroInterno) === null || _a === void 0 ? void 0 : _a.message}`);
                        console.error(chalk_1.default.red(`Pilha de execução: `) +
                            `${(_b = erroEmJavaScript.erroInterno) === null || _b === void 0 ? void 0 : _b.stack}`);
                    }
                    else {
                        console.error(chalk_1.default.red(`Erro em JavaScript: `) +
                            JSON.stringify(erroInterpretador));
                    }
                }
            }
        }
        return {
            erros: retornoInterpretador.erros,
            resultado: retornoInterpretador.resultado,
        };
    }
    /**
     * Executa uma linha. Usado pelo modo LAIR e pelo servidor de depuração, quando recebe um comando 'avaliar'.
     * @param linha A linha a ser avaliada.
     * @returns O resultado da execução, com os retornos e respectivos erros, se houverem.
     */
    async executarUmaLinha(linha) {
        const retornoLexador = this.lexador.mapear([linha], -1);
        const retornoAvaliadorSintatico = this.avaliadorSintatico.analisar(retornoLexador, -1);
        if (this.afericaoErros({
            retornoLexador,
            retornoAvaliadorSintatico,
        })) {
            return { resultado: [] };
        }
        return await this.executar({
            retornoLexador,
            retornoAvaliadorSintatico,
        }, true);
    }
    /**
     * Instancia um servidor de depuração, normalmente recebendo requisições na porta 7777.
     */
    iniciarDepuracao() {
        this.servidorDepuracao = new depuracao_1.ServidorDepuracao(this);
        this.servidorDepuracao.iniciarServidorDepuracao();
        this.interpretador.finalizacaoDaExecucao =
            this.finalizarDepuracao.bind(this);
    }
    /**
     * Pede ao servidor de depuração que finalize a execução.
     * Se não for feito, o servidor de depuração mantém um _stream_ aberto e nunca finaliza.
     * Mais informações: https://stackoverflow.com/a/47456805/1314276
     */
    finalizarDepuracao() {
        if (this.servidorDepuracao) {
            this.servidorDepuracao.finalizarServidorDepuracao();
        }
    }
    erroEmTempoDeExecucao(erro) {
        var _a;
        const linha = ((_a = erro === null || erro === void 0 ? void 0 : erro.simbolo) === null || _a === void 0 ? void 0 : _a.linha) || (erro === null || erro === void 0 ? void 0 : erro.linha);
        const mensagem = (erro === null || erro === void 0 ? void 0 : erro.mensagem) || (erro === null || erro === void 0 ? void 0 : erro.message);
        console.error(chalk_1.default.red(`Erro: [Linha: ${linha}]`) + ` ${mensagem}`);
    }
}
exports.NucleoExecucao = NucleoExecucao;
//# sourceMappingURL=nucleo-execucao.js.map